# DiskANN-Research
This repo contains the following features:

For build,
1. Build DiskANN disk graph.
1. Build in-memory navigation graph, based on
    1. Nodes that are uniformly-sampled.
    1. Nodes that are generated by search frequency.
1. Perform Graph Partition on given base data, rely on
    1. The number of neighbours only
    2. Search frequency (four strategies?)

For search,

| | With Cache Nodes | With Nav Graph | With Graph Partition | With `use_ratio` |
| :--- | :---: | :---: | :---: | :---: |
| Beam Search | :dart: | :white_check_mark: | | |
| Page Search | :dart: | :white_check_mark: | :white_check_mark: | :white_check_mark: |

To run benchmarks, go to `scripts` directory and run

```bash
./run_benchmark.sh [debug/release] [build/build_mem/search] [knn/range]
```

Configure datasets and parameters in `scripts/config.sh` and the beginning of `scripts/run_benchmark.sh`.


## Uniformly Sampled In-memory Navigation Graph
For building, modify `MEM_R`, `MEM_BUILD_L`, `MEM_ALPHA`, `MEM_RAND_SAMPLING_RATE` and run 

```bash
./run_benchmark.sh [debug/release] build_mem
```

For searching, modify `mem_L` and `mem_topk` to enable
```bash
./run_benchmark.sh [debug/release] search [knn/range]
```
Set `mem_L` to `0` to disable. Default is disable.

---

## DiskANN

The goal of the project is to build scalable, performant, streaming and cost-effective approximate nearest neighbor search algorithms for trillion-scale vector search.
This release has the code from the [DiskANN paper](https://papers.nips.cc/paper/9527-rand-nsg-fast-accurate-billion-point-nearest-neighbor-search-on-a-single-node.pdf) published in NeurIPS 2019, 
the [streaming DiskANN paper](https://arxiv.org/abs/2105.09613) and improvements. 
This code reuses and builds upon some of the [code for NSG](https://github.com/ZJULearning/nsg) algorithm.

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or
contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

See [guidelines](CONTRIBUTING.md) for contributing to this project.



## Linux build:

Install the following packages through apt-get

```bash
sudo apt install cmake g++ libaio-dev libgoogle-perftools-dev clang-format libboost-all-dev
```

### Install Intel MKL
#### Ubuntu 20.04
```bash
sudo apt install libmkl-full-dev
```

#### Earlier versions of Ubuntu
Install Intel MKL either by downloading the [oneAPI MKL installer](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) or using [apt](https://software.intel.com/en-us/articles/installing-intel-free-libs-and-python-apt-repo) (we tested with build 2019.4-070 and 2022.1.2.146).

```
# OneAPI MKL Installer
wget https://registrationcenter-download.intel.com/akdlm/irc_nas/18487/l_BaseKit_p_2022.1.2.146.sh
sudo sh l_BaseKit_p_2022.1.2.146.sh -a --components intel.oneapi.lin.mkl.devel --action install --eula accept -s
```

### Build
```bash
mkdir build && cd build && cmake -DCMAKE_BUILD_TYPE=Release .. && make -j 
```

## Windows build:

The Windows version has been tested with Enterprise editions of Visual Studio 2022, 2019 and 2017. It should work with the Community and Professional editions as well without any changes. 

**Prerequisites:**

* CMake 3.15+ (available in VisualStudio 2019+ or from https://cmake.org)
* NuGet.exe (install from https://www.nuget.org/downloads)
    * The build script will use NuGet to get MKL, OpenMP and Boost packages.
* DiskANN git repository checked out together with submodules. To check out submodules after git clone:
```
git submodule init
git submodule update
```

* Environment variables: 
    * [optional] If you would like to override the Boost library listed in windows/packages.config.in, set BOOST_ROOT to your Boost folder.

**Build steps:**
* Open the "x64 Native Tools Command Prompt for VS 2019" (or corresponding version) and change to DiskANN folder
* Create a "build" directory inside it
* Change to the "build" directory and run
```
cmake ..
```
OR for Visual Studio 2017 and earlier:
```
<full-path-to-installed-cmake>\cmake ..
```
* This will create a diskann.sln solution. Open it from VisualStudio and build either Release or Debug configuration.
    * Alternatively, use MSBuild:
```
msbuild.exe diskann.sln /m /nologo /t:Build /p:Configuration="Release" /property:Platform="x64"
```
    * This will also build gperftools submodule for libtcmalloc_minimal dependency.
* Generated binaries are stored in the x64/Release or x64/Debug directories.

## Usage:

Please see the following pages on using the compiled code:

- [Commandline interface for building and search SSD based indices](workflows/SSD_index.md)  
- [Commandline interface for building and search in memory indices](workflows/in_memory_index.md) 
- [Commandline examples for using in-memory streaming indices](workflows/dynamic_index.md)
- To be added: Python interfaces and docker files
